
def iterative_deepening_search(graph, start, goal):
    def dfs(node, depth, limit, path, visited):
        print(node, end=" ")
        if node == goal:
            return path
        if depth == limit:
            return None
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                result = dfs(neighbor, depth + 1, limit, path + [neighbor], visited | {neighbor})
                if result:
                    return result
        return None

    limit = 0
    while True:
        print(f"\nDepth limit: {limit}")
        result = dfs(start, 0, limit, [start], {start})
        if result:
            print("\nOptimal path from", start, "to", goal, ":", result)
            break
        limit += 1

graph = {
    'A': ['B', 'C', 'D'],
    'B': ['E', 'F'],
    'C': ['G'],
    'D': ['H'],
    'E': ['I'],
    'F': ['J', 'K'],
    'G': ['L'],
    'H': ['M', 'N'],
    'K': ['O', 'P'],
    'L': ['R'],
    'N': ['S']
}

start = input("Enter start node (S): ").strip()
goal = input("Enter goal node (G): ").strip()
iterative_deepening_search(graph, start, goal)

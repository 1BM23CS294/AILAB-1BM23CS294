def calculate_cost(board):
    conflicts = 0
    n = len(board)
    for i in range(n):
        for j in range(i + 1, n):
            if board[i] == board[j] or abs(board[i] - board[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def generate_neighbors(board):
    neighbors = []
    n = len(board)
    for col in range(n):
        for row in range(n):
            if board[col] != row:
                new_board = board[:]
                new_board[col] = row
                neighbors.append(new_board)
    return neighbors

def hill_climbing_from_start(start_board):
    current = start_board[:]
    step = 0

    while True:
        cost = calculate_cost(current)
        print(f"Step {step}: State={current}, Cost={cost}")
        if cost == 0:
            print("Solution found!\n")
            break
        
        neighbors = generate_neighbors(current)
        neighbor_costs = [(neighbor, calculate_cost(neighbor)) for neighbor in neighbors]
        best_neighbor, best_cost = min(neighbor_costs, key=lambda x: x[1])
        
        if best_cost >= cost:
            print("Stuck at local minimum, no better moves.\n")
            break
        
        current = best_neighbor
        step += 1

print("SAMIR CHAUDHARY")
print("1BM23CS294\n")

# Six predefined starting boards for 4 queens
starting_boards = [
    [0, 1, 2, 3],  # worst: all queens on diagonal, many conflicts
    [3, 1, 2, 0],
    [1, 3, 0, 2],
    [2, 0, 3, 1],  # known solution actually
    [3, 2, 1, 0],
    [0, 2, 3, 1]
]

for i, board in enumerate(starting_boards, 1):
    print(f"--- Case {i} ---")
    hill_climbing_from_start(board)
